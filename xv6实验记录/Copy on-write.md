# Lab: Copy-on-Write Fork for xv6
****
本实验所用的代码在分支 cow
```
git checkout cow
```

## 课程笔记
****
### 页面错误异常
许多内核使用页面错误来实现写时拷贝版本的`fork`。现在的 xv6 系统通过调用`uvmcopy`(__*kernel/vm.c*__:309)使子级具有相同的内存内容。

RISC-V 有三种不同的页面错误：加载页面错误(当加载指令无法转化其虚拟地址时)，存储页面错误(当存储指令无法转换其虚拟地址时)和指令页面错误(当指令的地址无法转换时)。`scause`寄存器中的值指示页面错误的类型，`stval`寄存器包含无法翻译的地址。

COW fork中的基本计划是让父子最初共享所有物理页面，但将它们映射为只读。因此，当子级或父级执行存储指令时，risc-v CPU引发页面错误异常。为了响应此异常，内核复制了包含错误地址的页面。它在子级的地址空间中映射一个权限为读/写的副本，在父级的地址空间中映射另一个权限为读/写的副本。更新页表后，内核会在导致故障的指令处恢复故障进程的执行。由于内核已经更新了相关的PTE以允许写入，所以错误指令现在将正确执行。

除COW fork以外，页表和页面错误的结合还开发出了广泛有趣的可能性。另一个广泛使用的特性叫做惰性分配——_lazy allocation。它包括两部分内容：首先，当应用程序调用`sbrk`时，内核增加地址空间，但在页表中将新地址标记为无效。其次，对于包含于其中的地址的页面错误，内核分配物理内存并将其映射到页表中。由于应用程序通常要求比他们需要的更多的内存，惰性分配可以称得上一次胜利: 内核仅在应用程序实际使用它时才分配内存。像COW fork一样，内核可以对应用程序透明地实现此功能。

利用页面故障的另一个广泛使用的功能是从磁盘分页。如果应用程序需要比可用物理RAM更多的内存，内核可以换出一些页面: 将它们写入存储设备 (如磁盘)，并将它们的PTE标记为无效。如果应用程序读取或写入被换出的页面，则CPU将触发页面错误。然后内核可以检查故障地址。如果该地址属于磁盘上的页面，则内核分配物理内存页面，将该页面从磁盘读取到该内存，将PTE更新为有效并引用该内存，然后恢复应用程序。为了给页面腾出空间，内核可能需要换出另一个页面。此功能不需要对应用程序进行更改，并且如果应用程序具有引用的地址 (即，它们在任何给定时间仅使用其内存的子集)，则该功能可以很好地工作。

结合分页和页面错误异常的其他功能包括自动扩展栈空间和内存映射文件。

### 结合页面错误完成的函数

__*zero fill in demand*__    
`BSS`区域包含了未被初始化或者初始化为0的全局变量，也就是说`BSS`段包含了很多的`page`，但是所有的`page`都为0，因此不如直接在`BSS`段申请一个`page`，所有变量都映射到这个`page`上。这个`page`必须只能是可读的，设置`pte`。当对其中的一个全局变量要重写的话，需要重新申请一块虚拟内存，并改变映射关系。

__*copy on write fork*__  
举个例子，在`shell`进程当中就是`fork`得到一个子进程并在子进程调用`exec`，也就是说`fork`时候子进程完整拷贝了父进程的数据，但是调用`exec`又丢弃了这部分内存。因此，有这样的一个优化，在创建子进程的时候，可以直接共享父进程的物理`page`，设置子进程的`pte`对应物理内存的`page`，但这个时候需要将父进程和子进程的`pte`的标志位都设置成只读的。 当父进程或者子进程在更改内存的时候就会得到`page fault`，这时候会分配一个新的物理内存，并将数据进行拷贝，完成新的映射关系，更改相关的`pte`上的读写权限位置。 具体的做法：
1. 在`fork`的时候将子进程的用户空间直接映射到父进程的用户控件上，并回收相应物理页上的写权限  
2. 在遇到`page fault`的时候需要考察这个`va`是否是由`cow`造成的，如果是的话，则解除之前的映射，执行拷贝  
3. 当释放相应的物理页的时候，可能物理页还存在着其他的映射关系，需要使用引用计数  

__*demand paging*__
在未修改的xv6中，操作系统会加载程序内存的`text,data`区域，并且以`eager`的方式将这些区域加载进`page table`。但是可以先不加载指令，可以为`text`和`data`分配好地址段，但是相应的`pte`并不对应任何物理内存的`page`。这种方法需要在某个地方记录这些`page`对应的程序文件，然后在`page fault`处理中读取这些程序文件

__*memory mapped files*__
将完整的或者部分的文件加载到内存当中。一个现代的操纵系统会提供一个叫`mmap`的系统调用，这个系统调用会接收一个虚拟地址（va），长度（len），protection，一些标志位，一个打开的文件描述符和偏移量：从文件描述符对应的文件的偏移量的位置开始，映射长度为`len`的内容到虚拟地址`va`。当去修改文件内容的时候就可以直接修改内存中的数据，另外要注意的是`pte`中有一个`dirty bit`表明当前页是否被修改，完成上述的操作后会有一个对应的`unmap`系统调用，将`dirty block`写回到文件中去。 当然，将文件写到内存的这种操作是以`lazy`的形式去实现的。

## Implement copy-on write
****
xv6 中的`fork`系统调用将父进程的所有用户空间内存复制到子进程中。如果父对象很大，则复制需要很长的时间。而且这项工作很大可能会被浪费，在`fork`完成之后经常会调用`exec`，这会导致子进程丢弃父进程复制来的内存。

在用户层中实现一个可执行程序`cowtest`(__*user/cowest.c*__)，其中一个测试是分配超过半数的物理页面，如果这时候调用`fork`，若没有`cow`机制则会失败。

注意点：  
1. 修改`uvmcopy`将父级的物理页面映射到子级，而不是分配新的页面，并且清除父级和子级`PTE`中的`PTE_W`。  
```c
/*
输入1个父进程页表，1个子进程页表
为子进程申请新的物理页面并拷贝父进程虚拟地址1-已用地址的内容
*/
int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  uint flags;
  char *mem;
  /*从虚拟地址0到已用的虚拟地址处*/
  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if((*pte & PTE_V) == 0)
      panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);
    flags = PTE_FLAGS(*pte);
    if((mem = kalloc()) == 0)
      goto err;
	/*输入的memove的两个物理地址，但是这在内核态中是可以被访问的*/
    memmove(mem, (char*)pa, PGSIZE);
    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
      kfree(mem);
      goto err;
    }
  }
```
子进程拷贝父进程内存空间源代码如上  

2. 修改`usertrap`以识别页面错误，当`cow`页面出现页面错误的时候，使用`kalloc`分配一个新的页面，将旧的页面复制到新的页面，并设置`PTE`。当寄存器`scause`读取出来的值为15或者13的时候则为一个页面错误

3. 确保每个物理页在最后一个`PTE`引用消失时都被释放，需要为每个物理页面保留引用该页面的用户表数量的引用计数。其具体的操作是在`kalloc`分配页面时，将页面的引用计数设置为1。当`fork`导致子级共享物理页面的时候，引用计数加1。每当任何进程将页面从其页面表中删除时，减少页面的计数。只有当引用计数为0的时候，`kfree`才将页面放回空闲链表。可以通过物理页面除以4094来索引数组，在`kinit`中初始化这个数组

4. 修改`copyout`，当它遇到`cow`时采用相同的机制处理  

代码的具体实现可以查看 commit 多条记录(记录 cow 的commit)