# Lab: page tables
****
本实验所用的代码在分支 pgtbl
```
git checkout pgtbl
```

## 课程笔记
****
## 页表
页表是操作系统为每个进程提供私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理地址哪些部分是可以访问的。并且支持一些特殊的操作：映射相同的内存到不同的地址空间(trampoline page)，还可以用一个未映射的页面保护内核和用户栈区

xv6 基于 Sv39 RISC-V 运行，这意味着它使用64位虚拟地址的低39位，而高25位不使用。$2^{39}$使得该系统虚拟内存拥有512g。在这种配置下，RISC-V 页表在逻辑上是一个由 $2^{27}$ 个页表条目(Page Table Entries/PTE)组成的数组，每个 PTE 包含一个44位的物理页码(Physical Page Number/PPN)和一些标志。

分页硬件通过虚拟地址39位中前27位索引页表，这对应页表条目数量，找到该虚拟地址对应的一个PTE，然后生成一个56位的物理地址，也就是物理内存大小为$2^{56}$，其中前44位来自PTE中的PPN，12位来自原始虚拟地址。也正因为如此，页表能使操作系统以 4096($2^{12}$) 字节的对齐块的粒度控制虚拟地址到物理地址的转换，这样的块称为页。
![[Pasted image 20230814223848.png]]

## 多级页表
在 xv6 真实的操作系统，虚拟地址向物理地址的转换其实是分三个步骤进行的。页表以三级的树型结构存储在物理内存中。该树的根是一个4096字节的页表页，(注意这是存储在一个物理地址下的)，其中包含512个 PTE(每个 PTE 占8个字节)，分支硬件使用27位中的前9位在根页表页面寻址，中间9位在树的下一级页表页面中选择 PTE，最后9位选择最终的 PTE。
![[Pasted image 20230814225821.png]]

如果转换地址过程所需的三个 PTE 任何一个不存在，页式硬件就会引发 page fault。

这样的设计方式的目的是为了节省内存，只需要加载所需的 PTE 对应的页表即可。但这样带来的缺点是寻址一个虚拟地址必须三次从物理内存中加载 PTE，为了减少这一开销，cpu将页表条目缓存在 TLB 当中。

每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。标志和所有其他与页面硬件相关的结构在（**_kernel/riscv.h_**）中定义。

为了告诉硬件使用页表，内核必须将根页表页的物理地址写入到`satp`寄存器中（`satp`的作用是存放根页表页在物理内存中的地址）。每个CPU都有自己的`satp`，一个CPU将使用自己的`satp`指向的页表转换后续指令生成的所有地址。每个CPU都有自己的`satp`，因此不同的CPU就可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。

由于页目录位于物理内存中，内核可以通过使用标准存储指令写入 PTE 的虚拟地址来对页目录中的 PTE 内容进行编程。